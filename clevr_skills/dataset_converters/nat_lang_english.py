# Copyright (c) 2024 Qualcomm Technologies, Inc.
# All Rights Reserved.

from typing import Dict, List, Optional, Tuple

import numpy as np

from clevr_skills.dataset_converters.action_trace_converter import ActionTraceConverter
from clevr_skills.utils.logger import log
from clevr_skills.utils.visualize_prompt import PromptVisualizer


class NatLangEngActionTraceConverter(ActionTraceConverter):
    """
    This class converts an action trace to natural language (English) annotations.
    These can be used as a form of high-level control for a robot policy.
    """

    def __init__(self, traj_path: Optional[str] = None):
        """
        :param traj_path: path to trajectory
        """
        super().__init__(traj_path)

        self.output_coordinates = True

        # construct table for converting ActionTrace to "Python code"
        self._conversion_table = {
            "Solver": self.Solver_to_english,
            "BalanceScaleSolver": self.BalanceScaleSolver_to_english,
            "PickMove3dThrowSolver": self.PickMove3dThrowSolver_to_english,
            "PickMove3dPlaceSolver": self.PickMove3dPlaceSolver_to_english,
            "PushSolver": self.PushSolver_to_english,
            "PushAlongPathSolver": self.PushAlongPathSolver_to_english,
            "PickSolver": self.PickSolver_to_english,
            "Move3dSolver": self.Move3dSolver_to_english,
            "PlaceSolver": self.PlaceSolver_to_english,
            "PlaceOnActorSolver": self.PlaceOnActorSolver_to_english,
            "ToppleStructure": self.ToppleStructure_to_english,
            "Move3dTouchSolver": self.Move3dTouchSolver_to_english,
        }

    def extract_labels(
        self, prompt: str, action_trace: Optional[List] = None, success: Optional[np.ndarray] = None
    ) -> List[List[Tuple[int, int, str]]]:
        """
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace: Action trace for the entire sequence.
        :param success: Success (true, false) for the entire sequence.
        :return: Returns label for all steps , based on the action trace. List of List of
        Tuple[start_idx, end_idx, text].
        """
        if action_trace is None or success is None:  # load from traj_path, if not given by caller
            action_trace = self.traj.get_action_trace()
            success = self.traj.get_success()

        # Brute-force convert all steps, all levels of action into natural language
        labels = []
        for step_idx, act_trace in enumerate(action_trace):
            step_labels = []  # the labels for this step
            for at_idx, at in enumerate(act_trace):
                step_labels.append(
                    self.action_to_nat_lang(
                        at, success[step_idx], prompt, act_trace[:at_idx], step_labels
                    )
                )
            labels.append(step_labels)

        # condense labels into the return format
        max_depth = max((len(l) for l in labels))
        condensed_labels = []
        for d in range(max_depth):
            cd = []  # condensed_labels for depth "d"
            prev_label = None
            prev_label_start_idx = -1
            for step_idx in range(len(action_trace)):
                next_label = labels[step_idx][d] if len(labels[step_idx]) > d else None
                if next_label != prev_label:
                    if not prev_label is None:
                        cd.append((prev_label_start_idx, step_idx, prev_label))
                    prev_label = next_label
                    prev_label_start_idx = step_idx
            if not prev_label is None:
                cd.append((prev_label_start_idx, len(action_trace), prev_label))
            condensed_labels.append(cd)

        return condensed_labels

    def action_to_nat_lang(
        self,
        action_trace: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts a single action_trace into a natural language string.
        :param action_trace: A single dict described the state of a solver.
        :param success: the "success" return value of the previous environment step.
        :param prompt: the prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: The actions for the higher level actions
        (all the way up to the prompt). i.e., a list of dict describing the state of solvers.
        :param labels_higher_levels: The labels (as generated by this function) for the higher
        level actions (all the way up to the prompt)
        :return: a natural language string that describes the action of action_trace
        """
        solver_class = action_trace["solver_class"]
        if solver_class in self._conversion_table:
            return self._conversion_table[solver_class](
                action_trace, success, prompt, action_trace_higher_levels, labels_higher_levels
            )

        log(
            f"Warning: conversion of action trace to English not implemented "
            f"yet for {solver_class}"
        )
        return action_trace["solver_class"] + "# to do: not implemented yet"

    def actor_to_nat_lang(self, actor: Tuple[str, int]):
        """
        Converts an actor (name, id) to a natural langauge string
        :param actor: (name, id)
        :return: Just the name of the actor.
        """
        return actor[0]

    def Solver_to_english(
        self,
        action_trace: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts top-level solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        pv = PromptVisualizer()
        if not prompt is None:
            if "{" in prompt and "}" in prompt:  # perform substitution of placeholders with English
                prompt = pv.visualize_prompt(
                    prompt, self.traj_path, PromptVisualizer.NATURAL_LANGUAGE, compose_image=False
                )[0]
        elif self.traj_path:
            prompt = action_trace["prompts"][0]  # pick the first prompt
            prompt = pv.visualize_prompt(
                prompt, self.traj_path, PromptVisualizer.NATURAL_LANGUAGE, compose_image=False
            )[0]
        else:
            prompt = action_trace["prompts"][0]
        return prompt

    def BalanceScaleSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts BalanceScale solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        # Get names of all actors to be placed on the scale. Make them plural if there are multiple
        all_actor_names = [self.actor_to_nat_lang(actor) for actor in at["objects"]]
        actor_names_str = ""
        unique_actor_names = sorted(list(set(all_actor_names)))
        for idx, name in enumerate(unique_actor_names):
            if idx == len(unique_actor_names) - 1:
                actor_names_str += " and "
            elif idx > 0:
                actor_names_str += ", "

            actor_names_str += f"the {name}{'s' if all_actor_names.count(name) > 1 else ''}"

        nl = f"Place {actor_names_str} onto the scale while keeping it in balance"
        return nl

    def PickMove3dThrowSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts PickMove3dThrow solver to English.
        Picking up ACTOR to throw it at TARGET_ACTOR
        Winding back to throw ACTOR at TARGET_ACTOR
        Throwing ACTOR at TARGET_ACTOR
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        throw_actor_nl = self.actor_to_nat_lang(at["throw_actor"])
        target_actor_nl = self.actor_to_nat_lang(at["target_actor"])
        preposition = "onto" if not at["topple_target"] and at["target_2d"] else "at"

        nl = None
        if "action" in at:
            # Temporary solution (until sub-solvers are properly in place)
            if at["action"] == "picking":
                nl = (
                    f"Pick up the {throw_actor_nl} in order to throw it {preposition} "
                    f"the {target_actor_nl}"
                )
            elif at["action"] == "winding":
                nl = (
                    f"Wind back while holding the {throw_actor_nl} in order to "
                    f"throw it {preposition} the {target_actor_nl}"
                )
            elif at["action"] == "throwing":
                nl = f"Throw the {throw_actor_nl} {preposition} the {target_actor_nl}"
            elif at["action"] == "waiting":
                nl = (
                    f"Waiting for the {throw_actor_nl} to settle and throw it {preposition} "
                    f"the {target_actor_nl}"
                )
        if nl is None:
            nl = f"Pick up the {throw_actor_nl} and throw {preposition} the {target_actor_nl}"

        if at["topple_target"]:
            nl += " in order to topple it"

        if "target_pos" in at and not at["target_pos"] is None:
            target_pos = at["target_pos"]
            nl += (
                f". The target is around {target_pos[0]:.3f}, {target_pos[1]:.3f}, "
                f"{target_pos[1]:.3f}"
            )
        return nl

    def PickMove3dPlaceSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts PickMove3dPlace solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        if "target_pose_function" in at:
            target_pose_function = at["target_pose_function"]
            if target_pose_function == "on_top":
                return (
                    f"Pick the {self.actor_to_nat_lang(at['actor'])} and place it on "
                    f"the {self.actor_to_nat_lang(at['target_actor'])}"
                )
            if target_pose_function == "rearrange":
                return (
                    f"Pick the {self.actor_to_nat_lang(at['actor'])} and place it as "
                    f"in the keystep image"
                )
            if target_pose_function == "rotate":
                restore = (
                    at["restore"] if "restore" in at else False
                )  # old data does not have restore
                angle = -at["angle"] if restore else at["angle"]
                direction = "clockwise" if angle < 0 else "anti-clockwise"
                angle = int(abs(angle))
                return (
                    f"Pick the {self.actor_to_nat_lang(at['actor'])} and rotate it "
                    f"{angle} degrees {direction}"
                )
            if target_pose_function == "free_space":
                return f"Pick the {self.actor_to_nat_lang(at['actor'])} and move it to free space"
            if target_pose_function == "swap":
                return (
                    f"Pick the {self.actor_to_nat_lang(at['actor'])} and move it where "
                    f"the {self.actor_to_nat_lang(at['target_actor'])} used to be at"
                )
            if target_pose_function == "swap_rotate":
                angle = at["angle"]
                direction = "clockwise" if angle < 0 else "anti-clockwise"
                angle = int(abs(angle))
                return (
                    f"Pick the {self.actor_to_nat_lang(at['actor'])} and move it where the "
                    f"{self.actor_to_nat_lang(at['target_actor'])} used to be at, but rotated by "
                    f"{angle} degrees {direction}"
                )
            if target_pose_function == "in_area":
                area_actor_str = (
                    " " + self.actor_to_nat_lang(at["area_actor"]) if "area_actor" in at else ""
                )
                return (
                    f"Pick the {self.actor_to_nat_lang(at['actor'])} and place it "
                    f"{at['area_description']}{area_actor_str}"
                )
            return (
                f"PickAndPlace: unimplemented target_pose_function {target_pose_function} "
                f"for nat lang english"
            )
        if at["target_pose"] is None:
            if at["target_actor"] is None:
                return f"Pick the {self.actor_to_nat_lang(at['actor'])} and lift it"
            return (
                f"Pick the {self.actor_to_nat_lang(at['actor'])} and place it on "
                f"the {self.actor_to_nat_lang(at['target_actor'])}"
            )
        return f"{at['solver_class']}: This case is not implemented yet."

    def PushSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts Push solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        if "target_pose_function" in at:
            target_pose_function = at["target_pose_function"]
            if target_pose_function == "free_space":
                return f"Push the {self.actor_to_nat_lang(at['actor'])} to free space"
            if target_pose_function == "swap":
                return (
                    f"Push the {self.actor_to_nat_lang(at['actor'])} to where "
                    f"the {self.actor_to_nat_lang(at['target_actor'])} used to be at"
                )
            if target_pose_function == "towards":
                return f"Push the {self.actor_to_nat_lang(at['actor'])} towards the {self.actor_to_nat_lang(at['target_actor'])}"
            return (
                f"PushSolver_to_english: unimplemented target_pose_function "
                f"{target_pose_function} for nat lang english"
            )
        return "PushSolver_to_english: This case is not implemented"

    def PushAlongPathSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts PushAlongPath solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        target_pos_2d = at["path"][-1]
        return (
            f"Push the {self.actor_to_nat_lang(at['actor'])} to "
            f"{target_pos_2d[0]:.3f}, {target_pos_2d[1]:.3f}"
        )

    def PickSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts Pick solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        return f"Pick up the {self.actor_to_nat_lang(at['actor'])}"

    def Move3dSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts Move3d solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        tpn = at["target_pose_name"]
        if "obj:" in tpn:
            tpn = tpn.split("obj:")[1]
            tpn = "_".join(tpn.split("_")[:-1])

        nl = f"Move to the {tpn}"

        if self.output_coordinates and "target_pose" in at:
            p = at["target_pose"][0]
            nl += f" (end effector at {p[0]:.3f} {p[1]:.3f} {p[2]:.3f})"

        if "grasped_actors" in at:
            if len(at["grasped_actors"]) > 0:
                nl += " while carrying the " + ", ".join(
                    [self.actor_to_nat_lang(actor) for actor in at["grasped_actors"]]
                )

        elif at["vacuum"]:
            nl += " while carrying an object"

        return nl

    def PlaceSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts Place solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        nl = f"Place the {self.actor_to_nat_lang(at['actor'])} at the {at['target_pose_name']}"
        if self.output_coordinates and "target_pose" in at:
            p = at["target_pose"][0]
            nl += f" (end effector at {p[0]:.3f} {p[1]:.3f} {p[2]:.3f})"
        return nl

    def PlaceOnActorSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts PlaceOnActor solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        nl = (
            f"Place the {self.actor_to_nat_lang(at['actor'])} on the "
            f"{self.actor_to_nat_lang(at['target_actor'])}"
        )

        if self.output_coordinates and "target_pose" in at:
            p = at["target_pose"][0]
            nl += f" (end effector at {p[0]:.3f} {p[1]:.3f} {p[2]:.3f})"

        return nl

    def ToppleStructure_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts ToppleStructure solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        nl = "Topple the structure consisting of"
        for idx, actor in enumerate(at["actors"]):
            if idx == 0:
                nl += " "
            elif idx == len(at["actors"]) - 1:
                nl += " and "
            else:
                nl += ", "
            nl += self.actor_to_nat_lang(actor)
        return nl

    def Move3dTouchSolver_to_english(
        self,
        at: Dict,
        success: bool,
        prompt: str,
        action_trace_higher_levels: List[Dict],
        labels_higher_levels: List[str],
    ) -> str:
        """
        Converts Move3dTouch solver to English.
        :param action_trace: The action trace entry.
        :param success: Whether the task has succeeded at this step.
        :param prompt: The prompt relative to which the labels should be extracted.
        :param action_trace_higher_levels: Action trace for higher solver levels.
        :param labels_higher_levels: The natural language description of for higher solver levels.
        :return: String described the action of the solver in natural language.
        """
        if at["topple"]:
            return f"Topple the {self.actor_to_nat_lang(at['actor'])}"
        if at["push"]:
            return f"Push the {self.actor_to_nat_lang(at['actor'])}"
        return f"Touch the {self.actor_to_nat_lang(at['actor'])}"
